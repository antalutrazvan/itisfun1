export { future as theme } from 'mdx-deck/themes'
import { CodeSurfer } from "mdx-deck-code-surfer"
import oceanicNext from "prism-react-renderer/themes/oceanicNext"

# ITisFun 

## Session One

Let's talk about some interesting, but often confusing topics:

- Scope
- Hoisting
- Closures

---
## Scope

"Scope refers to the `part` of a program where a `name binding` can be defined and is visible."

---
What's a name binding you may ask?

---
<CodeSurfer 
theme={oceanicNext}
notes="what are name bindings? "
dark="true"
code={require("raw-loader!./snippets/vars.jsx")}
steps={[
  { lines: [3, 4, 5], notes: "variable declaration"},
  { lines: [8, 9, 10], notes: "function declaration" }
]}  
/>

---

Now that that's out of the way, let's get back to **scope**.

---
 *Scope* can be:
- global
- file
- module
- function 
- block
---
Javascript has `global` and `function` scopes.

`block` scope was added as part of the `ES6`.

---
<CodeSurfer 
title="Global Scope"
theme={oceanicNext}
notes="global scope"
dark="true"
code={require("raw-loader!./snippets/global_cards.html")}
steps={[
  { lines: [1,2,4,5,6,9], notes: "let's load 2 separate scripts"},
  { range: [1,3], notes: "One with an array of cards"},
  { lines: [7], notes: "And one to log it" },
  { lines: [8], notes: "`cards` is visible" },
  { lines: [8], notes: "because it was defined in the global scope" },
  { lines: [8], notes: "it can also be accessed through: `window.cards`" },
  { range: [1, 9] }
]}  
/>
---
We can throw a wrench in this, by creating a `function`.
---
Let's look at a definition of what function scope is, and then modify our previous snippet.
---
### Function Scope

A programming language has function scope when: 

"A `function` `body` will automatically define a `variable` or `name context` when it it `called`."

---
<CodeSurfer 
title="Function Scope"
theme={oceanicNext}
notes="function scope"
dark="true"
code={require("raw-loader!./snippets/local_cards.html")}
steps={[
  { lines: [1,2,8, 9,10,18], notes: "let's load 2 separate scripts again"},
  { range: [3,7], notes: "One with a function that creates and returns some cards"},
  { lines: [11, 13, 16], notes: "and one to call the function and log the array" },
  { lines: [13, 14], notes: "`cards` is undefined in the global scope" },
  { lines: [3, 4], notes: "it exists in the scope of `getSomeCards`" },
  { lines: [11, 16, 17], notes: "our new variable `actualCards` is a reference to it" },
  { range: [1, 18] }
]}  
/>
---

### Block scope

  "A programing language has `block` level scope, if a `{}` `block` (or some other sintax)
  defines a variable scope."

---
<CodeSurfer 
title="Block Scope"
theme={oceanicNext}
notes="simple block scope example"
dark="true"
code={require("raw-loader!./snippets/block_scope.jsx")}
steps={[
  { lines: [1,2,21], notes: "the `main` function will be our first scope"},
  { lines: [1,2,3,21], notes: "it defines a `counter` variable with the value 2"},
  { lines: [1,2,3, 16, 21], notes: "and increments it"},
  { lines: [1,2,3, 16, 17, 18, 19, 20, 21], notes: "the result will be 3"},
  { lines: [5,6, 14], notes: "we define a block before incrementing counter"},
  { lines: [5,6, 7, 14], notes: "with it's own counter variable"},
  { lines: [5,6, 7, 9, 14], notes: "and increment that"},
  { lines: [5,6, 7, 9, 10, 11, 12, 13, 14], notes: "the result will be 4, because it's referencing counter from within the block"},
  { lines: [5, 6, 7], notes: "This works because we use `let` to define the block scoped variable"},
  { lines: [5, 6, 7], notes: "using var, we would overwrite the counter variable" },
  { range: [1, 21] }
]}  
/>
---

We're almost done with `scopes`.

An important feature to note is that nested function `scopes` are `chained`.

What that means is that, an `inner function`, has access to all the variables of an `outer function`.
But not the inverse.

---
<CodeSurfer 
title="Scope Chaining"
theme={oceanicNext}
notes="square number example"
dark="true"
code={require("raw-loader!./snippets/scope_chain.jsx")}
steps={[
  { lines: [1, 3, 4, 18], notes: "let's create a function to square a number" },
  { lines: [1, 3, 4, 12, 16,  17], notes: "but because programmers are mischevious creatures" },
  { lines: [6, 7, 9, 10, 18, 17], notes: "let's nest a function that will return 0 if the square is even" },
  { lines: [4, 7, 12, 14], notes: "if we log each variable..." },
  { lines: [14, 15], notes: "we can see that secretResult is undefined" },
  { lines: [14, 15], notes: "but result was referenced correctly" },
  { range: [1, 18] },
]}  
/>
---

Why could I `call` `square(6)` if I defined it after ?

Well, it works because of `hoisting`.
---
### Hoisting

Hoisting is a nifty feature where `named` `function` declarations are moved to the `top` of the script.

---
<CodeSurfer 
title="Hoisting"
theme={oceanicNext}
notes="logger example"
dark="true"
code={require("raw-loader!./snippets/hoisting_logger.jsx")}
steps={[
  { lines: [17, 24], notes: "let's create a logger function" },
  { range: [17, 24], notes: "that will log a pretty message" },
  { lines: [1, 9], notes: "We'll call it two times with diferent messages" },
  { lines: [1, 9], notes: "We can call it here because it will be hoisted before execution" },
  { range: [1, 6], notes: "at first it will say" },
  { lines: [8, 15], notes: "and around the 1 minute mark" },
  { range: [8, 15], notes: "it will tell you to get more supply" },
  { range: [0, 24] },
]}  
/>
---

We can extend our logger to be able to create functions with preset names or levels.

Doing this, we'll get to make use of `Closures`.

---
<CodeSurfer 
title="Closure"
theme={oceanicNext}
notes="logger example"
dark="true"
code={require("raw-loader!./snippets/closure_logger.jsx")}
steps={[
]}  
/>
---

## Functions

`"subroutines"`

 - they are groups of statements or expressions - `function body`
 - that can be `called` - either externaly or internaly (recursion)
 - they can recieve `arguments` for each `call` and can `return` a value at any point during execution.
---
# Fin...