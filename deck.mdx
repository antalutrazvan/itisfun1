export { future as theme } from 'mdx-deck/themes'
import { CodeSurfer } from "mdx-deck-code-surfer"
import oceanicNext from "prism-react-renderer/themes/oceanicNext"

# `ITisFun` 

### Session One

---

Let's talk about some interesting, but often confusing topics:

- Scope
- Hoisting
- Closures

---
## Scope

"Scope refers to the `part` of a program where a `name binding` can be defined and is visible."

---
What's a name binding you may ask?

---
<CodeSurfer 
theme={oceanicNext}
notes="what are name bindings? "
dark="true"
code={require("raw-loader!./snippets/vars.jsx")}
steps={[
  { lines: [3, 4, 5], notes: "variable declaration"},
  { lines: [8, 9, 10], notes: "function declaration" }
]}  
/>

---

Now that that's out of the way, let's get back to **scope**.

---
 *Scope* can be:
- global
- file
- module
- function 
- block
---
JavaScript has `global` and `function` scopes.

`block` scope was added as part of `ES6`.

---
<CodeSurfer 
title="Global Scope"
theme={oceanicNext}
notes="global scope"
dark="true"
code={require("raw-loader!./snippets/global_cards.html")}
steps={[
  { lines: [1,2,4,5,6,9], notes: "let's load 2 separate scripts"},
  { range: [1,3], notes: "One with an array of cards"},
  { lines: [7], notes: "And one to log it" },
  { lines: [8], notes: "`cards` is visible" },
  { lines: [8], notes: "because it was defined in the global scope" },
  { lines: [8], notes: "it can also be accessed through: `window.cards`" },
  { range: [1, 9] }
]}  
/>
---
We can throw a wrench in this, by creating a `function`.
---
Let's look at a definition of what function scope is, and then modify our previous snippet.
---
### Function Scope

A programming language has function scope when: 

"A `function` `body` will automatically define a `variable` or `name context` when it it `called`."

---
<CodeSurfer 
title="Function Scope"
theme={oceanicNext}
notes="function scope"
dark="true"
code={require("raw-loader!./snippets/local_cards.html")}
steps={[
  { lines: [1,2,8, 9,10,18], notes: "let's load 2 separate scripts again"},
  { range: [3,7], notes: "One with a function that creates and returns some cards"},
  { lines: [11, 13, 16], notes: "and one to call the function and log the array" },
  { lines: [13, 14], notes: "`cards` is undefined in the global scope" },
  { lines: [3, 4], notes: "it exists in the scope of `getSomeCards`" },
  { lines: [11, 16, 17], notes: "our new variable `actualCards` is a reference to it" },
  { range: [1, 18] }
]}  
/>
---

### Block scope

  "A programing language has `block` level scope, if a `{}` `block` (or some other sintax)
  defines a variable scope."

---
<CodeSurfer 
title="Block Scope"
theme={oceanicNext}
notes="simple block scope example"
dark="true"
code={require("raw-loader!./snippets/block_scope.jsx")}
steps={[
  { lines: [1,2,21], notes: "the `main` function will be our first scope"},
  { lines: [1,2,3,21], notes: "it defines a `counter` variable with the value 2"},
  { lines: [1,2,3, 16, 21], notes: "and increments it"},
  { lines: [1,2,3, 16, 17, 18, 19, 20, 21], notes: "the result will be 3"},
  { lines: [5,6, 14], notes: "we define a block before incrementing counter"},
  { lines: [5,6, 7, 14], notes: "with it's own counter variable"},
  { lines: [5,6, 7, 9, 14], notes: "and increment that"},
  { lines: [5,6, 7, 9, 10, 11, 12, 13, 14], notes: "the result will be 4, because it's referencing counter from within the block"},
  { lines: [5, 6, 7], notes: "This works because we use `let` to define the block scoped variable"},
  { lines: [5, 6, 7], notes: "using var, we would overwrite the counter variable" },
  { range: [1, 21] }
]}  
/>
---

We're almost done with `scopes`.

An important feature to note is that nested function `scopes` are `chained`.

What that means is that, an `inner function`, has access to all the variables of an `outer function`.
But not the inverse.

---
<CodeSurfer 
title="Scope Chaining"
theme={oceanicNext}
notes="square number example"
dark="true"
code={require("raw-loader!./snippets/scope_chain.jsx")}
steps={[
  { lines: [1, 3, 4, 18], notes: "let's create a function to square a number" },
  { lines: [1, 3, 4, 12, 16,  17], notes: "but because programmers are mischevious creatures" },
  { lines: [6, 7, 9, 10, 18, 17], notes: "let's nest a function that will return 0 if the square is even" },
  { lines: [4, 7, 12, 14], notes: "if we log each variable..." },
  { lines: [14, 15], notes: "we can see that secretResult is undefined" },
  { lines: [14, 15], notes: "but result was referenced correctly" },
  { range: [1, 18] },
]}  
/>
---

Why could I `call` `square(6)` if I defined it after ?

Well, it works because of `hoisting`.
---
### Hoisting

Hoisting is a feature where `variable` and `named` `function` declarations are moved to the `top` of their scope.

---
<CodeSurfer 
title="Hoisting - Variable"
theme={oceanicNext}
notes="simple message example"
dark="true"
code={require("raw-loader!./snippets/hoisting_simple.jsx")}
steps={[
  { lines: [1, 4, 6], notes: "lets take these 3 statements" },
  { lines: [1], notes: "we log a `message` variable" },
  { lines: [4], notes: "then declare, and assign a value to it." },
  { lines: [6], notes: "then then log it again." },
  { range: [1, 2], notes: "We would expect a ReferenceError at the first log" },
  { range: [1, 7], notes: "but because of variable hoisting" },
  { range: [9, 16], notes: "The interpeter will read this" },
  { range: [18, 22], notes: "same behaviour for function scopes" },
  { range: [25, 30], notes: "the interpreter will see" },
  { range: [1, 30] },
]}  
/>
---
<CodeSurfer 
title="Hoisting - Function"
theme={oceanicNext}
notes="logger example"
dark="true"
code={require("raw-loader!./snippets/hoisting_logger.jsx")}
steps={[
  { lines: [17, 24], notes: "let's create a logger function" },
  { range: [17, 24], notes: "that will log a pretty message" },
  { lines: [1, 9], notes: "We'll call it two times with diferent messages" },
  { lines: [1, 9], notes: "We can call it here because it will be hoisted before execution" },
  { range: [1, 6], notes: "at first it will say" },
  { lines: [8, 15], notes: "and around the 1 minute mark" },
  { range: [8, 15], notes: "it will tell you to get more supply because you'll always forget to" },
  { range: [1, 24] },
]}  
/>
---

We can extend our logger to be able to create more of them, with preset names or levels.

Doing this, we'll get to make use of `Closures`.

---
`closures` are the ability of an inner function to have access to the scope above them,
even after the function that defined the scope has finished executing.
---
<CodeSurfer 
title="Closure"
theme={oceanicNext}
notes="logger example"
dark="true"
code={require("raw-loader!./snippets/closure_logger.jsx")}
steps={[
  {lines: [1, 16], notes: "we'll create a function that recieves some parameters"},
  {lines: [1,2,3,4,5,6, 16], notes: "creates a context object with those parameters"},
  {range: [8, 15], notes: "and returns an anonymous version of our logger function"},
  {range: [9, 14], notes: "which will reference that object and it's properties"},
  {range: [1, 16], notes: "we can call this function later to get multiple types of loggers"},
  {range: [1, 19], notes: "let's create 2 loggers"},
  {range: [18, 32], notes: "then we can call them with whatever message we want"},
  {range: [1, 32]},
]}  
/>
---
 Here's a more simple example
---
<CodeSurfer 
title="Closure - Extra"
theme={oceanicNext}
notes="list nodes example"
dark="true"
code={require("raw-loader!./snippets/list_extra.html")}
steps={[
  {lines: [1], notes: "lets create a list"},
  {lines: [2, 16], notes: "and a script to modify that list"},
  {lines: [3, 4], notes: "it has some data, and a reference to that list"},
  {lines: [1, 6, 15], notes: "and for each entry"},
  {lines: [1, 6, 15, 7], notes: "we create a `li` node"},
  {lines: [1, 6, 15, 7,9 ], notes: "set its content"},
  {lines: [1, 6, 7, 9, 10, 15], notes: "and add it to the list"},
  {lines: [1, 6, 7, 9, 10, 12, 14, 15], notes: "afterwards we'll add a click listener"},
  {lines: [1, 6, 7, 9, 10, 12, 13, 14, 15], notes: "that logs each item"},
  {lines: [1, 6, 7, 9, 10, 12, 13, 14, 15, 17,18,19,20,21,22], notes: "when we click on each item, the value will be refrenced from the closure"},
  {range: [1, 22]}
]}  
/>
---
  We can make use of our knowledge of `closures`, `hoisting` and `scopes` to create interesting scripts.
  Closures for example are useful for creating `private` variables.
---
<CodeSurfer 
title="Closure - Extra"
theme={oceanicNext}
notes="shared stack example"
dark="true"
code={require("raw-loader!./snippets/stack_extra.jsx")}
steps={[
  {lines: [1, 40], notes: "we'll create a function that recieves a context"},
  {lines: [1, 40], notes: "and invoke it immediately"},
  {lines: [1, 2 ], notes: "we'll define a stack (array)"},
  {range: [15, 38], notes: "and some functions to interact with it"},
  {lines: [1, 4,5,6,7,8,9,10,11,12,13], notes: "on the context (window in our case) we'll add a function to return an interface object"},
  {lines: [1, 4,5,6,7,8,9,10,11,12,13], notes: "we could just set the object, but this is safer, as each call gets us a new interface"},
  {lines: [42, 43], notes: "we can now get an interface instance" },
  {range: [42, 48], notes: "and play around with it" },
  {range: [51, 52], notes: "if we get another interface" },
  {range: [51, 54 ], notes: "and play around with that" },
  {range: [51, 58], notes: "we're modifing the shared `stack`" },
  {range: [51, 59], notes: "which is kept in a closure" },
  {range: [1, 59]},
]}  
/>
---
I encourage you to dig deeper into this, and experiment as much as you can.
They are concepts that will help you greatly in understanding and writing code.
And inch you closer to the goal of delivering better, more interesting products.
---
You can play around with these snippets, or make your own.
And you can find out more about these concepts here:
[https://hackernoon.com/execution-context-in-javascript-319dd72e8e2c](https://hackernoon.com/execution-context-in-javascript-319dd72e8e2c)
[https://scotch.io/tutorials/understanding-hoisting-in-javascript](https://scotch.io/tutorials/understanding-hoisting-in-javascript)
[https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8](https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8)

Good reads:
[JavaScript the Good Parts](http://shop.oreilly.com/product/9780596517748.do)
---
# Thank you